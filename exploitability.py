import pyspiel

from open_spiel.python.algorithms import best_response as pyspiel_best_response
from open_spiel.python.algorithms import policy_utils
from open_spiel.python.policy import python_policy_to_pyspiel_policy, TabularPolicy

class Exploitability:

    def __init__(self, game):
        self.br_processors = {
            0: None,
            1: None
        }

        if game.num_players() != 2:
            raise ValueError("Game must be a 2-player game")
        game_info = game.get_type()
        if game_info.dynamics != pyspiel.GameType.Dynamics.SEQUENTIAL:
            raise ValueError("The game must be turn-based, not {}".format(
                game_info.dynamics))
        if game_info.utility not in (pyspiel.GameType.Utility.ZERO_SUM,
                                     pyspiel.GameType.Utility.CONSTANT_SUM):
            raise ValueError(
                "The game must be constant- or zero-sum, not {}".format(
                    game_info.utility))

        self.root_state = game.new_initial_state()
        self.game = game

        self.all_states = None
        self.state_to_information_state = None

    def exploitability(self, policy):
        """Returns the exploitability of the policy in the game.
        This is implemented only for 2 players constant-sum games, and is equivalent
        to NashConv / num_players in that case. Prefer using `nash_conv`.
        Args:
          game: An open_spiel game, e.g. kuhn_poker
          policy: A `policy.Policy` object. This policy should depend only on the
            information state available to the current player, but this is not
            enforced.
        Returns:
          The value that this policy achieves when playing against the worst-case
          non-cheating opponent, averaged across both starting positions. It has a
          minimum of zero (assuming the supplied policy is non-cheating) and
          this bound is achievable in a 2p game.
        Raises:
          ValueError if the game is not a two-player constant-sum turn-based game.
        """
        nash_conv_value = -self.game.utility_sum()
        for best_responder in range(2):
            if self.br_processors[best_responder] is None:
                self.all_states, self.state_to_information_state = pyspiel_best_response.compute_states_and_info_states_if_none(self.game, self.all_states, self.state_to_information_state)
                policy_to_dict = policy_utils.policy_to_dict(
                    policy, self.game, self.all_states,
                    self.state_to_information_state)
                self.br_processors[best_responder] = pyspiel.TabularBestResponse(self.game, best_responder, policy_to_dict)
                brp = self.br_processors[best_responder]
            else:
                policy_to_dict = policy_utils.policy_to_dict(
                        policy, self.game, self.all_states,
                        self.state_to_information_state)
                brp = self.br_processors[best_responder]
                # TODO: use python_policy_to_pyspiel_policy instead of policy_to_dict
                brp.set_policy(policy_to_dict)

            br_value = pyspiel_best_response.CPPBestResponsePolicy(
                        self.game, best_responder, policy, best_response_processor=brp).value(self.root_state)
            nash_conv_value += br_value
        return nash_conv_value / self.game.num_players()


def map_policy(policy, mapping, perfect_game):
    mapped_policy = TabularPolicy(perfect_game)
    for perfect_info_state in mapped_policy.state_lookup:
        info_state = mapping[perfect_info_state]
        perfect_state_policy = mapped_policy.policy_for_key(perfect_info_state)
        state_policy = policy.policy_for_key(info_state)
        perfect_state_policy[:] = state_policy
    return mapped_policy


if __name__ == "__main__":
    from goofspiel_perfect import *
    from goofspiel_noorder import *
    from goofspiel_privateonly import *
    from goofspiel_nopo import *
    import os
    import pickle

    for name in ["noorder", "privateonly", "nopo"]:
        for nc, nt in [(3, 3), (4, 3), (4, 4), (5, 3)]:
            nc_str = f"num_cards={nc}"
            nt_str = f"num_turns={nt}"
            game = pyspiel.load_game(f"python_goofspiel_{name}({nc_str},{nt_str})")
            fname = f"python_goofspiel_{name}({nc_str},{nt_str}).pickle"
            print(fname)
            with open(f"models/{fname}", "rb") as f:
                solver = pickle.load(f)
            avg_policy = solver.average_policy()

            map_fname = f"python_goofspiel_perfect_to_{name}_infoset_mapping({nc_str},{nt_str}).pkl"
            with open(f"mappings/{map_fname}", "rb") as f:
                mapping = pickle.load(f)
            perfect_game = pyspiel.load_game(f"python_goofspiel_perfect({nc_str},{nt_str})")

            mapped_policy = map_policy(avg_policy, mapping, perfect_game)
            e = Exploitability(perfect_game)

            print(e.exploitability(mapped_policy))
