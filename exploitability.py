import pyspiel

from open_spiel.python.algorithms import best_response as pyspiel_best_response
from open_spiel.python.algorithms import policy_utils
from open_spiel.python.policy import python_policy_to_pyspiel_policy

class Exploitability:

    def __init__(self, game):
        self.br_processors = {
            0: None,
            1: None
        }

        if game.num_players() != 2:
            raise ValueError("Game must be a 2-player game")
        game_info = game.get_type()
        if game_info.dynamics != pyspiel.GameType.Dynamics.SEQUENTIAL:
            raise ValueError("The game must be turn-based, not {}".format(
                game_info.dynamics))
        if game_info.utility not in (pyspiel.GameType.Utility.ZERO_SUM,
                                     pyspiel.GameType.Utility.CONSTANT_SUM):
            raise ValueError(
                "The game must be constant- or zero-sum, not {}".format(
                    game_info.utility))

        self.root_state = game.new_initial_state()
        self.game = game

        self.all_states = None
        self.state_to_information_state = None

    def exploitability(self, policy):
        """Returns the exploitability of the policy in the game.
        This is implemented only for 2 players constant-sum games, and is equivalent
        to NashConv / num_players in that case. Prefer using `nash_conv`.
        Args:
          game: An open_spiel game, e.g. kuhn_poker
          policy: A `policy.Policy` object. This policy should depend only on the
            information state available to the current player, but this is not
            enforced.
        Returns:
          The value that this policy achieves when playing against the worst-case
          non-cheating opponent, averaged across both starting positions. It has a
          minimum of zero (assuming the supplied policy is non-cheating) and
          this bound is achievable in a 2p game.
        Raises:
          ValueError if the game is not a two-player constant-sum turn-based game.
        """
        nash_conv_value = -self.game.utility_sum()
        for best_responder in range(2):
            if self.br_processors[best_responder] is None:
                self.all_states, self.state_to_information_state = pyspiel_best_response.compute_states_and_info_states_if_none(self.game, self.all_states, self.state_to_information_state)
                policy_to_dict = policy_utils.policy_to_dict(
                    policy, self.game, self.all_states,
                    self.state_to_information_state)
                self.br_processors[best_responder] = pyspiel.TabularBestResponse(self.game, best_responder, policy_to_dict)
                brp = self.br_processors[best_responder]
            else:
                policy_to_dict = policy_utils.policy_to_dict(
                        policy, self.game, self.all_states,
                        self.state_to_information_state)
                brp = self.br_processors[best_responder]
                # TODO: use python_policy_to_pyspiel_policy instead of policy_to_dict
                brp.set_policy(policy_to_dict)

            br_value = pyspiel_best_response.CPPBestResponsePolicy(
                        self.game, best_responder, policy, best_response_processor=brp).value(self.root_state)
            nash_conv_value += br_value
        return nash_conv_value / self.game.num_players()
