import numpy as np

import pyspiel

from goofspiel_shift import SHIFT

class GoofspielStateBase(pyspiel.State):
    def __init__(self, game):
        """Constructor; should only be called by Game.new_initial_state."""
        super().__init__(game)
        self._num_players = game._num_players
        self._num_cards = game._num_cards
        self._num_turns = game._num_turns

        self.cards = np.ones((self._num_players, self._num_cards), dtype=int)
        self.bets = np.zeros((self._num_turns, self._num_players), dtype=int) - 1
        self.points = np.zeros(self._num_players, dtype=int)
        self.prizes = np.zeros(self._num_cards, dtype=int) - 1

        self._game_over = False
        self._current_turn = 0
        self._next_player = self._num_players

    # OpenSpiel (PySpiel) API functions are below. This is the standard set that
    # should be implemented by every sequential-move game with chance.

    def current_player(self):
        """Returns id of the next player to move, or TERMINAL if game is over."""
        if self._game_over:
            return pyspiel.PlayerId.TERMINAL
        elif self._next_player == self._num_players:
            return pyspiel.PlayerId.CHANCE
        else:
            return self._next_player

    def _legal_actions(self, player):
        """Returns a list of legal actions, sorted in ascending order."""
        assert player >= 0
        return np.where(self.cards[player] == 1)[0]

    def chance_outcomes(self):
        """Returns the possible chance outcomes and their probabilities."""
        assert self.is_chance_node()
        outcomes = [i for i in range(self._num_cards) if i not in self.prizes]
        p = 1.0 / len(outcomes)
        return [(o, p) for o in outcomes]

    def _apply_action(self, action):
        """Applies the specified action to the state."""
        if self.is_chance_node():
            self.prizes[self._current_turn] = action
        else:
            # make bet
            # self.cards[self._next_player, action] = 0
            self.bets[self._current_turn, self._next_player] = action
        self._next_player = self._next_player + 1 if self._next_player < self._num_players else 0
        # after all players have bet, reward the player with the highest bet
        # if highest bets tie, throw out the card
        if self._next_player == self._num_players:
            current_bets = self.bets[self._current_turn]
            for player, bet in enumerate(current_bets):
                self.cards[player, bet] = 0
            highest_bet = current_bets.max()
            highest_bidder = np.where(current_bets == highest_bet)[0]
            if len(highest_bidder) == 1:
                self.points[highest_bidder[0]] += self.prizes[self._current_turn] + 1
            self._current_turn += 1
        if self._current_turn == self._num_turns:
            self._game_over = True

    def _action_to_string(self, player, action):
        """Action -> string."""
        if player == pyspiel.PlayerId.CHANCE:
            return f"Deal:{action}"
        else:
            return f"Bet:{action}"

    def is_terminal(self):
        """Returns True if the game is over."""
        return self._game_over

    def returns(self):
        """Total reward for each player over the course of the game so far."""
        if not self._game_over:
            return [0.] * self._num_players
        else:
            highest_points = self.points.max()
            winners = np.where(self.points == highest_points)[0]
            if len(winners) == self._num_players:
                return [0.] * self._num_players
            return [1.0 / len(winners) if i in winners else -1.0 / (self._num_players - len(winners)) for i in range(self._num_players)]

    def __str__(self):
        """String for debug purposes. No particular semantics are required."""
        return (
            f"p{self.current_player()}\n"
            f"points: {self.points}\n"
            f"prizes: {self.prizes}\n"
            f"cards: {self.cards}\n"
            f"bets: {self.bets}\n\n"
        )

    def __repr__(self):
        """If reprs for two states are the same, but reprs for children
        generated by playing the same actions are different, then the game tree
        that we cache will not match the count of unique state reprs."""
        raise NotImplementedError


class GoofspielStatePerfect(GoofspielStateBase):
    def __repr__(self):
        """If reprs for two states are the same, but reprs for children
        generated by playing the same actions are different, then the game tree
        that we cache will not match the count of unique state reprs."""
        return (
            f"p{self.current_player()}"
            f"points: {(self.points * SHIFT['POINTS']).sum()}"
            f"prizes: {((self.prizes + 1) * SHIFT['PRIZES']).sum()}"
            f"cards: {(self.cards * SHIFT['CARDS']).sum()}"
            f"bets: {((self.bets + 1) * SHIFT['BETS']).sum()}"
        )


class GoofspielStateNoOrder(GoofspielStateBase):
    def __repr__(self):
        """If reprs for two states are the same, but reprs for children
        generated by playing the same actions are different, then the game tree
        that we cache will not match the count of unique state reprs."""
        return (
            f"p{self.current_player()}"
            f"points: {(self.points * SHIFT['POINTS']).sum()}"
            f"prizes: {((self.prizes + 1) * SHIFT['PRIZES']).sum()}"
            f"cards: {(self.cards * SHIFT['CARDS']).sum()}"
            f"bets: {((self.bets + 1) * SHIFT['BETS'])[self._current_turn].sum() if self._current_turn < self._num_turns else -1}"
        )
